## 贪心算法

## 动态规划
  动态规划算法通常基于一个递推公式及一个或多个初始状态。当前子问题的解将由上一次子问题的解推出。

## 二叉堆
> 二叉堆事完全二叉树或者是近似完全二叉树

**特点**

* 父节点的键值总是大于或等于(小于或等于) 任何一个子节点的键值
* 每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）

一般都用数组来表示堆，i结点的父结点下标为(i-1)/2,左右结点下标为2i+1,2i+2

堆的删除：按定义，堆中每次都只能删除第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点

## 排序算法
[排序算法](http://www.cnblogs.com/wxisme/p/5243631.html)

![排序](../sort/sort.jpg)
### 冒泡排序
> 时间复杂度O(n^2)

思想：通过与相邻元素的比较和交换来把小的数交换到最前面

对5,3,8,6,4这个无序序列进行冒泡排序。首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6,3和4无需交换。5和3交换，变成3,5,4,8,6,3.这样一次冒泡就完了，把最小的数3排到最前面了。对剩下的序列依次冒泡就会得到一个有序序列


[冒泡排序实现](./sort/bubbleSort.js)

### 选择排序
> 时间复杂度O(n^2)

思想：在一次排序后最小的元素放到最前面，但是和冒泡排序的过程不同，冒泡排序是通过相邻的比较和交换，而选择排序是通过对整体的选择

对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4.对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。

[选择排序实现](./sort/selectSort.js)

### 插入排序
> 时间复杂度O(n^2)

思想：插入排序是通过比较找到合适的位置插入元素来达到排序的目的(类似于打扑克牌的原理)

5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置时正确的，想一下在拿到第一张牌的时候，没必要整理。然后3要插到5前面，把5后移一位，变成3,5,8,6,4.想一下整理牌的时候应该也是这样吧。然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经有序

[插入排序实现](./sort/insertSort.js)

### 快速排序
> 时间复杂度O(nlogn)

思想：思想来源于冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面

对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。5,3,8,6,4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。5,3,8,6,4 首先设置i,j两个指针分别指向两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。5,3,4,6,8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。4,3,5,6,8 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。

[快速排序实现](./sort/quickSort.js)


### 堆排序
> 时间复杂度O(nlogn)

思想：首先可以看到堆建好之后堆中第0个数据是堆中最小的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最小的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。

[堆排序实现](./sort/heapSort.js)

### 希尔排序（缩小增量排序）
> 时间复杂度O(nlogn)

思想：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时在对全体记录进行一次直接插入排序

[希尔排序实现](./sort/shellSort.js)

### 归并排序
> 时间复杂度O(nlogn)

思想：使用了递归分治的思想。将数组分成二组A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。

### 计数排序
> 时间复杂度O(n)

**前提**：待排序的数要满足一定的范围的证书，而且计数排序需要比较多的辅助空间

思想：用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列

### 桶排序
> 时间复杂度O(n)

思想：假设有一组长度为N的待排关键字序列K[1....n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]....B[M]中的全部内容即是一个有序序列

假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序后得到如图所示。只要顺序输出每个B[i]中的数据就可以得到有序序列了。
  
### 基数排序
> 时间复杂度O(n)

思想：基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。所谓的多关键字排序就是有多个优先级不同的关键字，比如说成绩的排序，如果两个人总分相同，则语文高的排在前面，语文成绩也相同则数学高的排在前面。。。如果对数字进行排序，那么个位、十位、百位就是不同优先级的关键字，如果要进行升序排序，那么个位、十位、百位优先级一次增加。基数排序是通过多次的收分配和收集来实现的，关键字优先级低的先进行分配和收集。



  
    

